use std::env;
use std::path::PathBuf;
use std::fs;

/// Extracts the value of a define from FreeRTOSConfig.h
#[allow(dead_code)]
fn extract_define_value(content: &str, define_name: &str) -> Option<String> {
    for line in content.lines() {
        let line = line.trim();
        if line.starts_with(&format!("#define {}", define_name)) {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                let value = parts[2..].join(" ");
                let cleaned = value
                    .replace("(", "")
                    .replace(")", "")
                    .replace("TickType_t", "")
                    .replace("unsigned long", "")
                    .replace("unsigned short", "")
                    .replace("size_t", "")
                    .trim()
                    .to_string();
                return Some(cleaned);
            }
        }
    }
    None
}

/// Generates the commons file synchronized with FreeRTOSConfig.h
#[allow(dead_code)]
fn generate_constants_from_config() -> std::io::Result<()> {
    let config_path = PathBuf::from("include/FreeRTOSConfig.h");

    if !config_path.exists() {
        println!("cargo:warning=FreeRTOSConfig.h not found, using default values");
        return Ok(());
    }

    let content = fs::read_to_string(&config_path)?;

    let tick_rate = extract_define_value(&content, "configTICK_RATE_HZ")
        .unwrap_or_else(|| "1000".to_string());
    let max_priorities = extract_define_value(&content, "configMAX_PRIORITIES")
        .unwrap_or_else(|| "8".to_string());
    let minimal_stack = extract_define_value(&content, "configMINIMAL_STACK_SIZE")
        .unwrap_or_else(|| "128".to_string());
    let total_heap = extract_define_value(&content, "configTOTAL_HEAP_SIZE")
        .unwrap_or_else(|| "15 * 1024".to_string());
    let max_task_name = extract_define_value(&content, "configMAX_TASK_NAME_LEN")
        .unwrap_or_else(|| "16".to_string());
    let cpu_clock = extract_define_value(&content, "configCPU_CLOCK_HZ")
        .unwrap_or_else(|| "1000000000".to_string());

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let constants_path = out_dir.join("freertos_constants_generated.rs");

    let constants_code = format!(
r#"// AUTOMATICALLY GENERATED BY build.rs
// DO NOT MODIFY MANUALLY - Values are synchronized from include/FreeRTOSConfig.h
// To modify, edit FreeRTOSConfig.h and recompile

use crate::freertos::ffi::TickType_t;

/// Tick rate in Hz (number of ticks per second)
/// Synchronized from configTICK_RATE_HZ in FreeRTOSConfig.h
pub const CONFIG_TICK_RATE_HZ: TickType_t = {};

/// Maximum number of supported priorities
/// Synchronized from configMAX_PRIORITIES in FreeRTOSConfig.h
pub const CONFIG_MAX_PRIORITIES: u32 = {};

/// Minimum stack size (in words, not bytes)
/// Synchronized from configMINIMAL_STACK_SIZE in FreeRTOSConfig.h
pub const CONFIG_MINIMAL_STACK_SIZE: u32 = {};

/// Total heap size in bytes
/// Synchronized from configTOTAL_HEAP_SIZE in FreeRTOSConfig.h
pub const CONFIG_TOTAL_HEAP_SIZE: usize = {};

/// Maximum length of task name
/// Synchronized from configMAX_TASK_NAME_LEN in FreeRTOSConfig.h
pub const CONFIG_MAX_TASK_NAME_LEN: usize = {};

/// CPU clock frequency in Hz
/// Synchronized from configCPU_CLOCK_HZ in FreeRTOSConfig.h
pub const CONFIG_CPU_CLOCK_HZ: u64 = {};

/// Helper function to get tick period in milliseconds
pub fn get_tick_period_ms() -> u32 {{
    1000 / CONFIG_TICK_RATE_HZ
}}

/// Helper function to convert milliseconds to ticks
pub fn ms_to_ticks(milliseconds: u32) -> TickType_t {{
    (milliseconds * CONFIG_TICK_RATE_HZ) / 1000
}}

/// Helper function to convert ticks to milliseconds
pub fn ticks_to_ms(ticks: TickType_t) -> u32 {{
    (ticks * 1000) / CONFIG_TICK_RATE_HZ
}}

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_tick_period() {{
        let period = get_tick_period_ms();
        assert!(period > 0, "Tick period must be positive");
    }}

    #[test]
    fn test_conversions() {{
        let original_ms = 1000;
        let ticks = ms_to_ticks(original_ms);
        let converted_ms = ticks_to_ms(ticks);
        assert_eq!(original_ms, converted_ms, "Round-trip conversion must be accurate");
    }}
}}
"#,
        tick_rate, max_priorities, minimal_stack, total_heap, max_task_name, cpu_clock
    );

    fs::write(&constants_path, constants_code)?;

    println!("cargo:warning=âœ“ FreeRTOS constants auto-synchronized from FreeRTOSConfig.h");
    println!("cargo:warning=  configTICK_RATE_HZ = {}", tick_rate);
    println!("cargo:warning=  configMAX_PRIORITIES = {}", max_priorities);

    Ok(())
}

#[cfg(feature = "freertos")]
fn main() {
    let _out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // Compile FreeRTOS only if the "freertos" feature is enabled
    #[cfg(feature = "freertos")]
    {
        // Synchronize constants from FreeRTOSConfig.h
        if let Err(e) = generate_constants_from_config() {
            println!("cargo:warning=Failed to generate constants: {}", e);
        }

        // Configure CMake to download and compile FreeRTOS
        let mut cmake_config = cmake::Config::new(".");
        cmake_config.define("FREERTOS_VERSION", "V11.2.0");

        // Add FREERTOS_PORT and FREERTOS_HEAP parameters if specified
        if let Ok(port) = env::var("FREERTOS_PORT") {
            cmake_config.define("FREERTOS_PORT", &port);
            println!("cargo:warning=Using custom FreeRTOS port: {}", port);
        }
        
        if let Ok(heap) = env::var("FREERTOS_HEAP") {
            cmake_config.define("FREERTOS_HEAP", &heap);
            println!("cargo:warning=Using custom FreeRTOS heap: heap_{}.c", heap);
        }

        let dst = cmake_config.build();

        println!("cargo:rustc-link-search=native={}", dst.join("lib").display());
        println!("cargo:rustc-link-lib=static=freertos");
        
        // Export FreeRTOS include directories for use in Rust code
        let freertos_include = dst.join("include/freertos");
        let freertos_config_include = PathBuf::from("include");

        // Print include paths for debugging
        println!("cargo:warning=FreeRTOS headers available at: {}", freertos_include.display());
        println!("cargo:warning=FreeRTOS kernel built at: {}", dst.display());

        // Generate Rust bindings for FreeRTOS headers using bindgen (if available)
        #[cfg(feature = "bindgen")]
        {
            let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
            let bindings = bindgen::Builder::default()
                .header("wrapper.h")
                .use_core()
                .clang_arg(format!("-I{}", freertos_include.display()))
                .clang_arg(format!("-I{}", freertos_config_include.display()))
                .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
                .generate()
                .expect("Unable to generate bindings");

            bindings
                .write_to_file(out_dir.join("freertos_bindings.rs"))
                .expect("Couldn't write bindings!");

            println!("cargo:warning=Generated FreeRTOS bindings at: {}/freertos_bindings.rs", out_dir.display());
        }

        // Export include directory as environment variable for manual FFI declarations
        println!("cargo:rustc-env=FREERTOS_INCLUDE_DIR={}", freertos_include.display());
        println!("cargo:rustc-env=FREERTOS_CONFIG_DIR={}", freertos_config_include.display());
    }
    
    // For POSIX link pthread library
    #[cfg(feature = "posix")]
    {
        #[cfg(feature = "bindgen")]
        {
            let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
            let bindings = bindgen::Builder::default()
                .header_contents("wrapper.h", r#"
                #include <pthread.h>
                #include <sys/time.h>
                #include <sys/resource.h>
                "#)
                .clang_arg("-I/usr/include")
                .use_core()
                .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
                .generate()
                .expect("Unable to generate bindings");

            bindings
                .write_to_file(out_dir.join("posix_bindings.rs"))
                .expect("Couldn't write bindings!");

            println!("cargo:warning=Generated POSIX bindings at: {}/posix_bindings.rs", out_dir.display());
        }
        println!("cargo:warning=Building with POSIX backend");
        println!("cargo:rustc-link-lib=pthread");
        println!("cargo:warning=Linking pthread library for POSIX threads");
    }
    
    // Rebuild if CMake files change (only for FreeRTOS)
    #[cfg(feature = "freertos")]
    {
        println!("cargo:rerun-if-changed=CMakeLists.txt");
        println!("cargo:rerun-if-changed=cmake/FreeRTOS.cmake");
        println!("cargo:rerun-if-changed=include/FreeRTOSConfig.h");
    }
    
    println!("cargo:rerun-if-changed=build.rs");
}

#[cfg(feature = "posix")]
fn main() {
    let _out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindgen::Builder::default()
        .header_contents("wrapper.h",
r#"
#include <pthread.h>
#include <time.h>
#include <sys/time.h>
#include <sys/resource.h>
"#)
        .clang_arg("-I/usr/include")
        .use_core()
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(out_dir.join("posix_bindings.rs"))
        .expect("Couldn't write bindings!");

    println!("cargo:warning=Generated POSIX bindings at: {}/posix_bindings.rs", out_dir.display());
    println!("cargo:warning=Building with POSIX backend");
    println!("cargo:rustc-link-lib=pthread");
    println!("cargo:warning=Linking pthread library for POSIX threads");
    println!("cargo:rerun-if-changed=build.rs");
}